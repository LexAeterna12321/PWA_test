{"version":3,"sources":["reducers.js","components/CounterButton.js","components/Header.js","components/Card.js","components/CardList.js","components/SearchBox.js","components/Scroll.js","components/ErrorBoundry.js","containers/App.js","actions.js","constans.js","serviceWorker.js","index.js"],"names":["initialStateSearch","searchField","initialStateRobots","robots","isPending","error","CounterButton","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","updateCount","setState","state","count","nextProps","nextState","react_default","a","createElement","color","props","onClick","Component","Header","src","alt","border","style","margin","components_CounterButton","Card","_ref","name","email","id","toggleActiveCard","className","concat","CardList","console","log","cardsArray","map","robot","src_components_Card","key","SearchBox","searchChange","onChange","type","placeholder","Scroll","overflowY","height","width","children","ErrorBoundry","hasError","info","App","e","target","classList","toggle","onRequestRobots","_this$props","onSearchChange","filteredRobots","filter","toLowerCase","includes","components_Header","components_SearchBox","components_Scroll","components_ErrorBoundry","components_CardList","connect","searchRobots","requestRobots","dispatch","event","payload","value","fetch","then","res","json","data","catch","err","Boolean","window","location","hostname","match","logger","createLogger","rootReducer","combineReducers","arguments","length","undefined","action","assign","store","createStore","applyMiddleware","ReduxThunk","ReactDOM","render","es","src_containers_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.42b1cf90.chunk.js","sourcesContent":["import {\r\n  CHANGE_SEARCH_FIELD,\r\n  REQUEST_ROBOTS_FAILED,\r\n  REQUEST_ROBOTS_PENDING,\r\n  REQUEST_ROBOTS_SUCCESS\r\n} from \"./constans\";\r\n\r\nconst initialStateSearch = {\r\n  searchField: \"\"\r\n};\r\n\r\nexport const searchRobots = (state = initialStateSearch, action = {}) => {\r\n  switch (action.type) {\r\n    case CHANGE_SEARCH_FIELD:\r\n      //   return { ...state, searchField: action.payload };\r\n      return Object.assign({}, state, { searchField: action.payload });\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nconst initialStateRobots = { robots: [], isPending: false, error: \"\" };\r\n\r\nexport const requestRobots = (state = initialStateRobots, action = {}) => {\r\n  switch (action.type) {\r\n    case REQUEST_ROBOTS_PENDING:\r\n      return Object.assign({}, state, { isPending: true });\r\n    case REQUEST_ROBOTS_SUCCESS:\r\n      return Object.assign({}, state, {\r\n        robots: action.payload,\r\n        isPending: false\r\n      });\r\n    case REQUEST_ROBOTS_FAILED:\r\n      return Object.assign({}, state, {\r\n        error: action.payload,\r\n        isPending: false\r\n      });\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\n// zamiast tego syntaxu z Object.assign() możemy użyć spreada {...state, nowa/zmienianaWłaściwość : action.payload}\r\n\r\n// Odpowiednio reducery są tworzone, żeby imitować początkowy state (initialState) z czystego reacta, gdzie tworzony był state w App komponencie. Następnie musimy przygotować reducera na odbieranie danych, tak jak odbierał je początkowo state przy czystym react.\r\n","import React, { Component } from \"react\";\r\n// import React, { PureComponent } from \"react\";\r\n\r\n// PureComponent rerenderuje się tylko wtedy, gdy zmieniają się jego propsy. inaczej nie będzie update'u. uważać na shallow comparison\r\n// class CounterButton extends PureComponent {\r\nclass CounterButton extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      count: 0\r\n    };\r\n  }\r\n  shouldComponentUpdate(nextProps, nextState) {\r\n    if (this.state.count !== nextState.count) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //   w pryzpadku kiedy używamy state w ten sposób, że wyprowadzamy nowy state używając starej wartości state, np tak jak poniżej podnosimy wartość countera o jeden na podstawie starego state dodajemy 1, najlepiej użyć funkcji. Wszystko dlatego, że update state'u nie jest synchroniczny, więc może się zachowywać nieprzewidywalnie, kiedy używamy zwyklego this.setState\r\n  updateCount = () => {\r\n    this.setState(state => {\r\n      return {\r\n        count: state.count + 1\r\n      };\r\n    });\r\n  };\r\n  render() {\r\n    return (\r\n      <button color={this.props.color} onClick={this.updateCount}>\r\n        Count: {this.state.count}\r\n      </button>\r\n    );\r\n  }\r\n}\r\n\r\nexport default CounterButton;\r\n","import React, { Component } from \"react\";\r\nimport CounterButton from \"./CounterButton\";\r\nclass Header extends Component {\r\n  // pozwala na kontrolę czy zmienić domyślną wartość zawsze rerenderuj na inną, jeżeli zwracamy zawsze false, komponent nigdy nie przejdzie przez ponowny render\r\n  //   shouldComponentUpdate(nextProps, nextState) {\r\n  //     return false;\r\n  //   }\r\n  render() {\r\n    return (\r\n      <div>\r\n        <img\r\n          src=\"https://fontmeme.com/permalink/190215/e4c1ced8a1b5ac6f4f3d251ad98b1fb8.png\"\r\n          alt=\"sega-font\"\r\n          border=\"0\"\r\n          style={{ margin: \"20px 0\" }}\r\n        />\r\n        <CounterButton color={\"red\"} />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Header;\r\n","import React from \"react\";\r\nimport \"./Card.css\";\r\nconst Card = ({ name, email, id, toggleActiveCard }) => {\r\n  return (\r\n    <div\r\n      className=\"card tc bg-light-green dib br3 ma2 grow bw2 shadow-5\"\r\n      onClick={toggleActiveCard}\r\n    >\r\n      <img\r\n        src={`https://robohash.org/${id}?set=set4&size=250x250`}\r\n        alt=\"robot\"\r\n      />\r\n      <div>\r\n        <h2>{name}</h2>\r\n        <p>{email}</p>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Card;\r\n","import React from \"react\";\r\nimport Card from \"../components/Card\";\r\n\r\nconst CardList = ({ robots, toggleActiveCard }) => {\r\n  console.log(\"CardList\");\r\n  const cardsArray = robots.map(robot => {\r\n    const { id, name, email } = robot;\r\n    return (\r\n      <Card\r\n        id={id}\r\n        name={name}\r\n        email={email}\r\n        key={id}\r\n        toggleActiveCard={toggleActiveCard}\r\n      />\r\n    );\r\n  });\r\n\r\n  return <div>{cardsArray}</div>;\r\n};\r\n\r\nexport default CardList;\r\n","import React from \"react\";\r\n\r\nconst SearchBox = ({ searchChange }) => {\r\n  console.log(\"SearchBox\");\r\n  return (\r\n    <div>\r\n      <input\r\n        onChange={searchChange}\r\n        className=\"pa3 ba b--green bg-lightest-blue\"\r\n        type=\"search\"\r\n        placeholder=\"search among kittens\"\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SearchBox;\r\n","import React from \"react\";\r\n\r\nconst Scroll = props => {\r\n  return (\r\n    <div\r\n      style={{\r\n        overflowY: \"scroll\",\r\n        border: \"1px solid black\",\r\n        height: \"500px\",\r\n        width: \"70%\",\r\n        margin: \"30px auto\"\r\n      }}\r\n    >\r\n      {props.children}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Scroll;\r\n","import React, { Component } from \"react\";\r\n// errorBoundry służy nam za block catch w js. Dzięki niemu możemy wyłapywać błędy pojawiające się w innych komponentach i odpowiednio reagować dbając o UX. Wystarczy złapać inne komponenty w ten komponent i użyć metody componentDidCatch().\r\nclass ErrorBoundry extends Component {\r\n  state = {\r\n    hasError: false\r\n  };\r\n\r\n  componentDidCatch(error, info) {\r\n    this.setState({ hasError: true });\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return <h1>Ooops an error!</h1>;\r\n    } else {\r\n      return this.props.children;\r\n    }\r\n  }\r\n}\r\n\r\nexport default ErrorBoundry;\r\n","import React, { Component } from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport Header from \"../components/Header\";\r\nimport CardList from \"../components/CardList\";\r\nimport SearchBox from \"../components/SearchBox\";\r\nimport Scroll from \"../components/Scroll\";\r\nimport ErrorBoundry from \"../components/ErrorBoundry\";\r\nimport { setSearchField, requestRobots } from \"../actions\";\r\n\r\nimport \"./App.css\";\r\nclass App extends Component {\r\n  // state = { cardActive: \"\" };\r\n  // dzięki reduxowi i redux thunk nie potrzebujemy już i state'a i async fetcha w componentDidMount. Wszystko przejmuje na siebie redux\r\n\r\n  // constructor() {\r\n  //   super();\r\n  //   this.state = { robots: [], cardActive: false };\r\n  // }\r\n\r\n  componentDidMount() {\r\n    // async /await\r\n    // const getUsers = async () => {\r\n    //   const resp = await fetch(\"https://jsonplaceholder.typicode.com/users/\");\r\n\r\n    //   return resp.json();\r\n    // };\r\n    // getUsers().then(res => this.setState({ robots: res }));\r\n    this.props.onRequestRobots();\r\n  }\r\n\r\n  toggleActiveCard = e => {\r\n    e.target.classList.toggle(\"active\");\r\n    // this.setState({ cardActive: e.target });\r\n  };\r\n\r\n  render() {\r\n    // const { robots } = this.state;\r\n    const { searchField, onSearchChange, robots, isPending } = this.props;\r\n    const filteredRobots = robots.filter(robot =>\r\n      robot.name.toLowerCase().includes(searchField.toLowerCase())\r\n    );\r\n\r\n    return isPending ? (\r\n      <div>Loading...</div>\r\n    ) : (\r\n      <div className=\"tc\">\r\n        <Header />\r\n        <SearchBox searchChange={onSearchChange} />\r\n        <Scroll>\r\n          <ErrorBoundry>\r\n            <CardList\r\n              robots={filteredRobots}\r\n              toggleActiveCard={this.toggleActiveCard}\r\n            />\r\n          </ErrorBoundry>\r\n        </Scroll>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n  return {\r\n    searchField: state.searchRobots.searchField,\r\n    robots: state.requestRobots.robots,\r\n    isPending: state.requestRobots.isPending,\r\n    error: state.requestRobots.error\r\n  };\r\n};\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n  return {\r\n    onSearchChange: event => dispatch(setSearchField(event.target.value)),\r\n    onRequestRobots: () => dispatch(requestRobots())\r\n  };\r\n};\r\n\r\nexport default connect(\r\n  mapStateToProps,\r\n  mapDispatchToProps\r\n)(App);\r\n\r\n// higher order function connect() zwraca funkcję, do której przekazujemy komponent App jako argument\r\n","import {\r\n  CHANGE_SEARCH_FIELD,\r\n  REQUEST_ROBOTS_FAILED,\r\n  REQUEST_ROBOTS_SUCCESS,\r\n  REQUEST_ROBOTS_PENDING\r\n} from \"./constans\";\r\n\r\nexport const setSearchField = text => ({\r\n  type: CHANGE_SEARCH_FIELD,\r\n  payload: text\r\n});\r\n\r\n// to tutaj działa async\r\n\r\n// ponieważ ten actionCreator zwraca funkcję zamiast obiektu, triggeruje się redux-thunk, do przekazywanej funkcji dajemy argument w postaci dispatch, żeby można było przesyłać akcje i dzięki temu zabiegowi możemy sobie robić asynchroniczne rzeczy. Na końcu i tak zwracany jest przez dispatch obiekt, który poprzez reducery zupdejtuje nam store i widok całej apki\r\nexport const requestRobots = () => dispatch => {\r\n  dispatch({ type: REQUEST_ROBOTS_PENDING });\r\n  fetch(\"https://jsonplaceholder.typicode.com/users/\")\r\n    .then(res => {\r\n      return res.json();\r\n    })\r\n    .then(data => dispatch({ type: REQUEST_ROBOTS_SUCCESS, payload: data }))\r\n    .catch(err => dispatch({ type: REQUEST_ROBOTS_FAILED, payload: err }));\r\n\r\n  // const getRobots = async () => {\r\n  //   const response = await fetch(\"https://jsonplaceholder.typicode.com/users/\");\r\n  //   return response.json();\r\n  // };\r\n  // getRobots().then(data =>\r\n  //   dispatch({ type: REQUEST_ROBOTS_SUCCESS, payload: data })\r\n  // );\r\n};\r\n// akcje tworzymy na podstawie zmian dokonywanych wcześniej za pomocą czystego reacta. Jeżeli na przykład mieliśmy seachField, które oddziaływało na state to tworzymy też taki action creator, który domyślnie nam przejmie ten proces od reacta. Mogą też operacje na stanie i operacje z użyciem reduxa istnieć obok siebie, ale to tylko w niektórych przypadkach warto stosować,(np formsy?).\r\n","export const CHANGE_SEARCH_FIELD = \"CHANGE_SEARCH_FIELD\";\r\n\r\nexport const REQUEST_ROBOTS_PENDING = \"REQUEST_ROBOTS_PENDING\";\r\nexport const REQUEST_ROBOTS_SUCCESS = \"REQUEST_ROBOTS_SUCCESS\";\r\nexport const REQUEST_ROBOTS_FAILED = \"REQUEST_ROBOTS_FAILED\";\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport { createStore, applyMiddleware, combineReducers } from \"redux\";\nimport { searchRobots, requestRobots } from \"./reducers\";\nimport { createLogger } from \"redux-logger\";\nimport ReduxThunk from \"redux-thunk\";\nimport \"./index.css\";\nimport \"tachyons\";\nimport App from \"./containers/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nconst logger = createLogger();\n\nconst rootReducer = combineReducers({ searchRobots, requestRobots });\n\nconst store = createStore(rootReducer, applyMiddleware(ReduxThunk, logger));\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}